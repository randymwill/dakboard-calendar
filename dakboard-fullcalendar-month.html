<!doctype html>
<!--
DAKBOARD CALENDAR (FullCalendar + Google ICS + Nutrislice Meals Footer)
Version: v1.12.7
Last Updated: 2025-12-15


New in v1.12.7:
- Fullscreen layout (calendar + sidebar on top, weather + Waze bottom)
- Weather panel uses Open-Meteo in Fahrenheit (no API key)

Previous:
- (from v1.11.2)

- Holiday mode (auto theme accents for seasonal/holiday periods)
- Fix: Sidebar/calendar initialization bug (JS syntax + status functions)
- Today Focus Sidebar (today's agenda + upcoming games countdowns)
- Christmas countdown remains a live running countdown (d/h/m/s)

Notes:
- Tune menu text size: search "MEALS FONT KNOBS"
- Tune calendar fonts: search "FONT TUNING (calendar)"
- Toggle new features: search "FEATURE TOGGLES"
-->

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DAKboard Calendar</title>

  <!-- FullCalendar -->
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.19/index.global.min.js"></script>
  <!-- ical.js -->
  <script src="https://unpkg.com/ical.js/dist/ical.es5.min.cjs"></script>
  <!-- FullCalendar iCalendar plugin -->
  <script src="https://cdn.jsdelivr.net/npm/@fullcalendar/icalendar@6.1.19/index.global.min.js"></script>

  <style>
    :root{
      --bg: #07101d;
      --panel: #0b1a2f;
      --panel2: #091527;

      --grid: rgba(255,255,255,0.20);
      --gridStrong: rgba(255,255,255,0.30);

      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.62);
      --todayBorder: rgba(56,189,248,0.85);

      --weekendTint: rgba(255,255,255,0.11);
      --weekendTint2: rgba(255,255,255,0.03);
      --weekendLine: rgba(255,255,255,0.28);

      --school: #ef4444;  /* red */
      --sports: #ec4899;  /* pink */
      --other:  #22d3ee;  /* cyan */
      --randy:  #3b82f6;  /* blue */
      --leslie: #22c55e;  /* green */

      --holidayGlow: rgba(250, 204, 21, 0.22);
      --holidayBorder: rgba(250, 204, 21, 0.62);
      --holidayLabelBg: rgba(0,0,0,0.48);

      --sparkleOuter: rgba(250, 204, 21, 0.50);
      --sparkleInner: rgba(255,255,255,0.22);

      --mealsBg: rgba(0,0,0,0.18);
      --mealsBorder: rgba(255,255,255,0.14);

      --ok: rgba(34,197,94,0.85);
      --warn: rgba(250,204,21,0.85);
      --err: rgba(239,68,68,0.85);

      #sidebar.christmas-accent .side-title-strong{
      text-shadow: 0 0 10px rgba(34,197,94,0.10);
    }

</style>
</head>

<body>

<div id="screen-grid">
  <div id="top-area">
    <div id="calendar-wrapper">
    <div id="calendar-card">
      <div class="holiday-accent-glow" id="holiday-accent-glow"></div>
<div id="main-row">
        <div id="calendar"></div>

        <aside id="sidebar" aria-label="Today Focus Sidebar">
          <div class="side-card">
            <div class="side-title">
              <span class="side-title-strong">Today</span>
              <span class="side-title-muted" id="today-date-label">‚Äî</span>
            </div>
            <div class="side-sub" id="today-summary">Loading‚Ä¶</div>

            <div class="side-section">
              <div class="side-section-title">Next up</div>
              <div id="today-upcoming" class="side-list"></div>
            </div>

            <div class="side-section">
              <div class="side-section-title">Games</div>
              <div id="today-games" class="side-list"></div>
            </div>
          </div>

          <div class="side-card side-card-small">
            <div class="side-title">
              <span class="side-title-strong">Status</span>
              <span class="side-title-muted" id="side-last-refresh">‚Äî</span>
            </div>
            <div class="side-sub" id="side-meals-status">Meals: ‚Äî</div>
          </div>
        </aside>
      </div>

      <div id="meals-footer">
        <div id="meals-grid"></div>
      </div>
    </div>
  </div>

  <div id="status-badge">
    <div class="ver">v1.11.2</div>
    <div class="ref" id="last-refreshed">Last refreshed: ‚Äî</div>
    <div class="menu" id="menu-status">Meals: <span class="warn">loading‚Ä¶</span></div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {

      // =========================================================
      // FEATURE TOGGLES (easy on/off)
      // =========================================================
      const SHOW_STATUS_BADGE = false;         // bottom-right version box
      const AUTO_HIDE_MEALS_FOOTER = true;     // hide footer on weekends or when no posted menu today
      const ENABLE_TODAY_FOCUS = true;         // highlight today's column + bigger event text
      const ENABLE_COUNTDOWN_CHIPS = true;     // "Game in‚Ä¶" chips
      const ENABLE_CHRISTMAS_COUNTDOWN = true; // chip next to title

      const ENABLE_HOLIDAY_MODE = false;        // auto seasonal accents
      const HOLIDAY_MODE_PREVIEW = "";         // e.g. "christmas" | "halloween" | "newyear" | "" (auto)


      // Sources
      const ICS_URL  = "https://snowy-silence-6676.randywilliams-us.workers.dev/";
      const MENU_URL = "https://cool-lake-2804.randywilliams-us.workers.dev/";

      // Refresh behavior
      const AUTO_REFRESH_MINUTES = 10;
      const COUNTDOWN_REFRESH_SECONDS = 1;

      // Meals formatting limits
      const BREAKFAST_MAX_ITEMS = 2;
      const LUNCH_MAX_ENTREES = 3;

      // Countdown behavior knobs
      const COUNTDOWN_MAX_PER_DAY = 1;
      const COUNTDOWN_LOOKAHEAD_DAYS = 14;

      // Status badge
      const statusBadge = document.getElementById("status-badge");
      if (statusBadge && !SHOW_STATUS_BADGE) statusBadge.classList.add("hidden");

      const lastRefEl = document.getElementById("last-refreshed");
      const sideLastRefEl = document.getElementById("side-last-refresh");
      const sideMealsStatusEl = document.getElementById("side-meals-status");
      const menuStatusEl = document.getElementById("menu-status");

      function setLastRefreshed(reason) {
        const now = new Date();
        const suffix = reason ? ` (${reason})` : "";
        const text = `Last refreshed: ${formatLocalTime(now)}${suffix}`;
        if (lastRefEl) lastRefEl.textContent = text;
        if (sideLastRefEl) sideLastRefEl.textContent = formatLocalTime(now);
      }

      function setMealsStatus(ok, msg) {
        if (menuStatusEl) {
          if (ok === true) {
            menuStatusEl.innerHTML = `Meals: <span class="ok">OK</span>${msg ? " - " + escapeHtml(msg) : ""}`;
          } else if (ok === false) {
            menuStatusEl.innerHTML = `Meals: <span class="err">Error</span>${msg ? " - " + escapeHtml(msg) : ""}`;
          } else {
            menuStatusEl.innerHTML = `Meals: <span class="warn">loading‚Ä¶</span>`;
          }
        }

        if (sideMealsStatusEl) {
          if (ok === true) sideMealsStatusEl.innerHTML = `Meals: <span class="ok">OK</span>${msg ? " - " + escapeHtml(msg) : ""}`;
          else if (ok === false) sideMealsStatusEl.innerHTML = `Meals: <span class="err">Error</span>${msg ? " - " + escapeHtml(msg) : ""}`;
          else sideMealsStatusEl.innerHTML = `Meals: <span class="warn">loading‚Ä¶</span>`;
        }
      }

      setLastRefreshed("loaded");
      setMealsStatus(null);

      applyHolidayMode();

      // Date helpers
      function startOfCurrentWeekSunday(d = new Date()) {
        const date = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        date.setDate(date.getDate() - date.getDay());
        date.setHours(0,0,0,0);
        return date;
      }

      function addDays(dateObj, days) {
        const d = new Date(dateObj);
        d.setDate(d.getDate() + days);
        return d;
      }

      function startOfDay(dateObj) {
        const d = new Date(dateObj);
        d.setHours(0,0,0,0);
        return d;
      }

      function sameDay(a, b) {
        return a.getFullYear() === b.getFullYear() &&
               a.getMonth() === b.getMonth() &&
               a.getDate() === b.getDate();
      }

      function toYYYYMMDD(dateObj) {
        const y = dateObj.getFullYear();
        const m = String(dateObj.getMonth() + 1).padStart(2, "0");
        const d = String(dateObj.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      }

      function formatLocalTime(dt) {
        const mm = dt.getMonth() + 1;
        const dd = dt.getDate();
        let hh = dt.getHours();
        const ampm = hh >= 12 ? "PM" : "AM";
        hh = hh % 12; if (hh === 0) hh = 12;
        const min = String(dt.getMinutes()).padStart(2, "0");
        return `${mm}/${dd} ${hh}:${min} ${ampm}`;
      }

      function holidayLabelForDate(dateObj) {
        const m = dateObj.getMonth() + 1;
        const d = dateObj.getDate();
        if (m === 12 && d === 24) return "üéÑ Christmas Eve";
        if (m === 12 && d === 25) return "üéÅ Christmas Day";
        if (m === 12 && d === 31) return "ü•Ç New Year‚Äôs Eve";
        return "";
      }

      function isBigHolidayDate(dateObj) {
        const m = dateObj.getMonth() + 1;
        const d = dateObj.getDate();
        return (m === 12 && (d === 24 || d === 25 || d === 31));
      }

      // Rules + icons
      const rules = {
        randy:  /randy/i,
        leslie: /leslie/i,
        school: /school|dismissal|class|winter break|no school/i,
        basketball: /basketball|bball|little dribblers/i,
        soccer: /soccer|rainbow unicorns/i,
        rainbowUnicorns: /rainbow unicorns/i
      };

      const ICON_BBALL  = "üèÄ";
      const ICON_SOCCER_RU = "üåàü¶Ñ‚öΩ";
      const ICON_SOCCER = "‚öΩ";
      const ICON_SCHOOL = "üêé";

      function classifyEvent(title) {
        if (rules.randy.test(title))      return { category: "randy",  icon: "" };
        if (rules.leslie.test(title))     return { category: "leslie", icon: "" };
        if (rules.basketball.test(title)) return { category: "sports", icon: ICON_BBALL, sport: "basketball" };
        if (rules.soccer.test(title)) {
          return { category: "sports", icon: rules.rainbowUnicorns.test(title) ? ICON_SOCCER_RU : ICON_SOCCER, sport: "soccer" };
        }
        if (rules.school.test(title))     return { category: "school", icon: ICON_SCHOOL };
        return { category: "other", icon: "" };
      }

      // Meals footer
      const mealsFooter = document.getElementById("meals-footer");
      const mealsGrid = document.getElementById("meals-grid");

      function setMealsFooterVisible(isVisible) {
        if (!mealsFooter) return;
        mealsFooter.classList.toggle("hidden", !isVisible);
      }

      function shouldShowMealsFooter(mealsByDate) {
        if (!AUTO_HIDE_MEALS_FOOTER) return true;

        const today = new Date();
        const dow = today.getDay();
        if (dow === 0 || dow === 6) return false;

        const todayKey = toYYYYMMDD(today);
        const info = mealsByDate && mealsByDate[todayKey];
        if (!info) return false;

        const hasBreakfast = (info.breakfastItems || []).length > 0;
        const hasLunch = (info.lunchEntrees || []).length > 0 || (info.lunchSides || "").length > 0;
        return hasBreakfast || hasLunch;
      }

      function parseMenuTitleParts(title) {
        const cleaned = (title || "").trim();
        const parts = cleaned.split("‚Äî Sides:");
        const left = (parts[0] || "").trim();
        const sides = (parts[1] || "").trim();
        const colonIdx = left.indexOf(":");
        const afterColon = colonIdx >= 0 ? left.slice(colonIdx + 1).trim() : left;
        const items = afterColon.split(" / ").map(s => s.trim()).filter(Boolean);
        return { items, sides };
      }

      function renderMealsFooter(weekStart, mealsByDate) {
        if (!mealsGrid) return;
        mealsGrid.innerHTML = "";

        for (let i = 0; i < 7; i++) {
          const key = toYYYYMMDD(addDays(weekStart, i));
          const info = mealsByDate[key] || {};
          const bItems = info.breakfastItems || [];
          const lEntrees = info.lunchEntrees || [];
          const lSides = info.lunchSides || "";

          const hasAny = (bItems.length > 0) || (lEntrees.length > 0) || (lSides && lSides.length > 0);

          const col = document.createElement("div");
          col.className = "meal-col" + (hasAny ? "" : " empty");

          if (hasAny) {
            if (bItems.length) {
              const row = document.createElement("div");
              row.className = "meal-row";
              row.innerHTML = `
                <span class="meal-pill">üç≥</span>
                <span class="meal-text-one">${escapeHtml(bItems.join(" / "))}</span>
              `;
              col.appendChild(row);
            }

            if (lEntrees.length || lSides) {
              const row = document.createElement("div");
              row.className = "meal-row";
              row.innerHTML = `
                <span class="meal-pill">ü•™</span>
                <span class="meal-lunch-wrap">
                  <span class="meal-lunch-entrees">${escapeHtml(lEntrees.join(" / "))}</span>
                  <span class="meal-lunch-sides">${lSides ? "Sides: " + escapeHtml(lSides) : ""}</span>
                </span>
              `;
              col.appendChild(row);
            }
          }

          mealsGrid.appendChild(col);
        }
      }

      async function fetchMealsForCurrentWeek() {
        const weekStart = startOfCurrentWeekSunday(new Date());
        const weekEnd = addDays(weekStart, 7);

        const start = toYYYYMMDD(weekStart);
        const end = toYYYYMMDD(weekEnd);
        const url = `${MENU_URL}?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;

        setMealsStatus(null);

      applyHolidayMode();

        const resp = await fetch(url, { cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

        const data = await resp.json();
        if (!Array.isArray(data)) throw new Error("Meals feed did not return an array");

        const byDate = {};
        for (const ev of data) {
          const dateKey = (ev && ev.start) ? String(ev.start).slice(0,10) : null;
          const meal = ev && ev.extendedProps && ev.extendedProps.meal;
          const title = ev && ev.title ? String(ev.title) : "";

          if (!dateKey || (meal !== "breakfast" && meal !== "lunch")) continue;

          const { items, sides } = parseMenuTitleParts(title);
          if (!byDate[dateKey]) byDate[dateKey] = { breakfastItems: [], lunchEntrees: [], lunchSides: "" };

          if (meal === "breakfast") {
            byDate[dateKey].breakfastItems = items.slice(0, BREAKFAST_MAX_ITEMS);
          } else {
            byDate[dateKey].lunchEntrees = items.slice(0, LUNCH_MAX_ENTREES);
            byDate[dateKey].lunchSides = sides || "";
          }
        }

        setMealsFooterVisible(shouldShowMealsFooter(byDate));
        renderMealsFooter(weekStart, byDate);
        setMealsStatus(true, `${data.length} menu events`);
      }

      
      // =========================================================
      // Holiday Mode (accent themes)
      // =========================================================
      function applyThemeVars(vars){
        const root = document.documentElement;
        for (const [k,v] of Object.entries(vars || {})) {
          root.style.setProperty(k, v);
        }
      }

      function getHolidayThemeKey(now){
        if (HOLIDAY_MODE_PREVIEW) return HOLIDAY_MODE_PREVIEW;

        const m = now.getMonth() + 1;
        const d = now.getDate();

        // Christmas season: Dec 10 -> Jan 2
        if ((m === 12 && d >= 10) || (m === 1 && d <= 2)) return "christmas";
        // Halloween season: Oct 15 -> Nov 1
        if ((m === 10 && d >= 15) || (m === 11 && d <= 1)) return "halloween";
        // New Year week: Dec 28 -> Jan 3 (handled by christmas, but keep for future)
        return "";
      }

      function applyHolidayMode(){
        if (!ENABLE_HOLIDAY_MODE) return;

        const now = new Date();
        const key = getHolidayThemeKey(now);

        const glow = document.getElementById("holiday-accent-glow");
        const festiveHeader = document.getElementById("festive-header-line");
        const sidebar = document.getElementById("sidebar");
        if (glow) glow.style.opacity = key ? "0.95" : "0.65";

        if (key === "christmas") {
          if (festiveHeader) festiveHeader.style.opacity = "0.95";
          if (sidebar) sidebar.classList.add("christmas-accent");
          applyThemeVars({
            "--todayBorder": "rgba(34,197,94,0.78)",     /* green */
            "--weekendLine": "rgba(239,68,68,0.55)",     /* red */
            "--holidayGlow": "rgba(34,197,94,0.18)",
            "--holidayBorder": "rgba(239,68,68,0.58)",
            "--chipBorder": "rgba(239,68,68,0.20)",
            "--chipBg": "rgba(0,0,0,0.36)"
          });
          if (glow) glow.style.background = "radial-gradient(closest-side, rgba(34,197,94,0.16), transparent 70%), radial-gradient(closest-side, rgba(239,68,68,0.12), transparent 70%)";
        } else if (key === "halloween") {
          applyThemeVars({
            "--todayBorder": "rgba(249,115,22,0.78)",    /* orange */
            "--weekendLine": "rgba(168,85,247,0.55)",    /* purple */
            "--holidayGlow": "rgba(249,115,22,0.20)",
            "--holidayBorder": "rgba(168,85,247,0.55)"
          });
          if (glow) glow.style.background = "radial-gradient(closest-side, rgba(249,115,22,0.18), transparent 70%), radial-gradient(closest-side, rgba(168,85,247,0.12), transparent 70%)";
        } else {
          // default (no override)
          applyThemeVars({});
          if (glow) glow.style.background = "radial-gradient(closest-side, rgba(255,255,255,0.10), transparent 70%)";
        }
      }

      // =========================================================
      // Today Focus Sidebar
      // =========================================================
      const todayDateLabelEl = document.getElementById("today-date-label");
      const todaySummaryEl = document.getElementById("today-summary");
      const todayUpcomingEl = document.getElementById("today-upcoming");
      const todayGamesEl = document.getElementById("today-games");

      function formatPrettyDate(d){
        return d.toLocaleDateString(undefined, { weekday: "long", month: "short", day: "numeric" });
      }

      function formatTimeShort(d){
        return d.toLocaleTimeString(undefined, { hour: "numeric", minute: "2-digit" });
      }

      function minutesUntil(dt){
        return Math.round((dt.getTime() - Date.now()) / 60000);
      }

      function humanWhen(dt){
        const mins = minutesUntil(dt);
        if (mins <= 0) return "now";
        if (mins < 60) return `in ${mins}m`;
        const hrs = Math.floor(mins/60);
        const rem = mins % 60;
        if (hrs < 24) return `in ${hrs}h ${rem}m`;
        const days = Math.floor(hrs/24);
        const hr = hrs % 24;
        return `in ${days}d ${hr}h`;
      }

      function dotColorForCategory(cat){
        if (cat === "school") return "var(--school)";
        if (cat === "sports") return "var(--sports)";
        if (cat === "leslie") return "var(--leslie)";
        if (cat === "randy") return "var(--randy)";
        return "var(--other)";
      }

      function renderSideList(container, items){
        if (!container) return;
        container.innerHTML = "";

        if (!items || items.length === 0){
          container.innerHTML = `<div class="side-item"><span class="dot" style="background:rgba(255,255,255,0.25)"></span><div class="txt"><div class="line1">Nothing scheduled</div><div class="line2">Enjoy the quiet üòå</div></div></div>`;
          return;
        }

        for (const it of items){
          const dot = dotColorForCategory(it.category);
          container.insertAdjacentHTML("beforeend", `
            <div class="side-item">
              <span class="dot" style="background:${dot}"></span>
              <div class="txt">
                <div class="line1">${escapeHtml(it.line1)}</div>
                <div class="line2">${escapeHtml(it.line2)}</div>
              </div>
            </div>
          `);
        }
      }

      function buildSidebarFromCalendar(){
        // If sidebar is hidden by media query, skip work.
        const sb = document.getElementById("sidebar");
        if (!sb || getComputedStyle(sb).display === "none") return;

        const now = new Date();
        if (todayDateLabelEl) todayDateLabelEl.textContent = formatPrettyDate(now);

        // Pull visible events from FullCalendar
        const events = calendar.getEvents ? calendar.getEvents() : [];
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0,0);
        const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23,59,59,999);

        const todays = [];
        const upcoming = [];
        const games = [];

        for (const ev of events){
          const title = (ev.title || "").trim();
          const meta = classifyEvent(title);
          const st = ev.start;
          if (!st) continue;

          const en = ev.end || new Date(st.getTime() + 60*60*1000);

          const isToday = (st.getTime() >= todayStart.getTime() && st.getTime() <= todayEnd.getTime()) ||
                          (en.getTime() >= todayStart.getTime() && en.getTime() <= todayEnd.getTime());

          const isFuture = en.getTime() >= now.getTime();

          if (isToday){
            todays.push({ ev, meta, st, en });
          } else if (isFuture){
            upcoming.push({ ev, meta, st, en });
          }

          if (meta.category === "sports" && isFuture){
            games.push({ ev, meta, st, en });
          }
        }

        // Sort
        todays.sort((a,b) => (a.st.getTime() - b.st.getTime()));
        upcoming.sort((a,b) => (a.st.getTime() - b.st.getTime()));
        games.sort((a,b) => (a.st.getTime() - b.st.getTime()));

        const nextUp = [];
        const maxUp = 6;

        // Prioritize remaining events today, then earliest future
        for (const t of todays){
          if (t.en.getTime() < now.getTime()) continue;
          const time = t.ev.allDay ? "All day" : `${formatTimeShort(t.st)}`;
          nextUp.push({
            category: t.meta.category,
            line1: `${t.meta.icon ? t.meta.icon + " " : ""}${t.ev.title}`,
            line2: `${time} ‚Ä¢ ${humanWhen(t.st)}`
          });
          if (nextUp.length >= maxUp) break;
        }
        if (nextUp.length < maxUp){
          for (const u of upcoming){
            if (nextUp.length >= maxUp) break;
            const time = u.ev.allDay ? "All day" : `${formatPrettyDate(u.st)} ${formatTimeShort(u.st)}`;
            nextUp.push({
              category: u.meta.category,
              line1: `${u.meta.icon ? u.meta.icon + " " : ""}${u.ev.title}`,
              line2: `${time} ‚Ä¢ ${humanWhen(u.st)}`
            });
          }
        }

        const gameItems = [];
        const maxGames = 3;
        for (const g of games){
          if (gameItems.length >= maxGames) break;
          // Only show games within next 14 days (matches chips)
          const horizon = new Date(); horizon.setDate(horizon.getDate() + COUNTDOWN_LOOKAHEAD_DAYS);
          if (g.st.getTime() > horizon.getTime()) continue;

          const when = `${formatPrettyDate(g.st)} ${formatTimeShort(g.st)}`;
          gameItems.push({
            category: "sports",
            line1: `${g.meta.icon ? g.meta.icon + " " : ""}${g.ev.title}`,
            line2: `${when} ‚Ä¢ ${humanWhen(g.st)}`
          });
        }

        // Summary line
        if (todaySummaryEl){
          const remainingToday = todays.filter(t => t.en.getTime() >= now.getTime()).length;
          const nextGame = games.find(g => g.st.getTime() >= now.getTime());
          const gameText = nextGame ? `${nextGame.meta.icon ? nextGame.meta.icon + " " : ""}${humanWhen(nextGame.st)}` : "no games soon";
          todaySummaryEl.textContent = `${remainingToday} remaining today ‚Ä¢ next game ${gameText}`;
        }

        renderSideList(todayUpcomingEl, nextUp);
        renderSideList(todayGamesEl, gameItems);
      }

// Countdown logic
      const dayChipElsByKey = new Map();
      let cachedSportsEvents = [];

      function ensureDayChip(dayEl, dateKey) {
        let el = dayChipElsByKey.get(dateKey);
        if (el && el.isConnected) return el;

        const frame = dayEl.querySelector(".fc-daygrid-day-frame") || dayEl;
        frame.style.position = "relative";

        el = document.createElement("div");
        el.className = "day-chip";
        el.style.display = "none";
        frame.appendChild(el);

        dayChipElsByKey.set(dateKey, el);
        return el;
      }

      function clearAllDayChips() {
        for (const [, el] of dayChipElsByKey) {
          if (el) el.style.display = "none";
        }
      }

      function humanCountdown(ms) {
        if (ms <= 0) return "now";
        const mins = Math.floor(ms / 60000);
        const hrs = Math.floor(mins / 60);
        const days = Math.floor(hrs / 24);
        if (days >= 1) return `${days}d`;
        if (hrs >= 1) return `${hrs}h`;
        return `${mins}m`;
      }

      function updateChristmasChip() {
        if (!ENABLE_CHRISTMAS_COUNTDOWN) return;

        const now = new Date();
        const year = now.getFullYear();

        // Count down to Dec 25 00:00:00 local time (next year's if already passed)
        let christmas = new Date(year, 11, 25, 0, 0, 0, 0); // Dec=11
        if (now > christmas) christmas = new Date(year + 1, 11, 25, 0, 0, 0, 0);

        const diffMs = christmas.getTime() - now.getTime();

        const totalSeconds = Math.max(0, Math.floor(diffMs / 1000));
        const days = Math.floor(totalSeconds / 86400);
        const hours = Math.floor((totalSeconds % 86400) / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const pad2 = (n) => String(n).padStart(2, "0");
        const countdown = `${days}d ${pad2(hours)}h ${pad2(minutes)}m ${pad2(seconds)}s`;

        const chipHtml = `<span class="title-chip">üéÑ <span class="muted">Christmas</span> ${countdown}</span>`;
        const titleEl = document.querySelector(".fc-toolbar-title");
        if (!titleEl) return;

        const existing = titleEl.querySelector(".title-chip");
        if (existing) existing.remove();

        titleEl.insertAdjacentHTML("beforeend", chipHtml);
      }

      function normalizeSportsEvents(fcEvents) {
        const out = [];
        const now = new Date();

        for (const e of fcEvents) {
          try {
            const title = (e.title || "").trim();
            const meta = classifyEvent(title);
            if (meta.category !== "sports") continue;

            const start = e.start;
            if (!start) continue;

            const end = e.end || new Date(start.getTime() + 60 * 60 * 1000);
            const endMs = end.getTime();

            if (endMs < now.getTime()) continue;

            out.push({
              title,
              start: new Date(start.getTime()),
              end: new Date(endMs),
              icon: meta.icon || "üèüÔ∏è"
            });
          } catch (err) {}
        }

        out.sort((a,b) => a.start.getTime() - b.start.getTime());
        return out;
      }

      function updateGameDayChips(visibleStart, visibleEnd) {
        if (!ENABLE_COUNTDOWN_CHIPS) return;

        clearAllDayChips();

        const now = new Date();
        const lookaheadEnd = addDays(startOfDay(now), COUNTDOWN_LOOKAHEAD_DAYS).getTime();

        const perDay = new Map();
        for (const ev of cachedSportsEvents) {
          const st = ev.start.getTime();
          if (st < now.getTime()) continue;
          if (st > lookaheadEnd) continue;
          if (st < visibleStart.getTime() || st >= visibleEnd.getTime()) continue;

          const key = toYYYYMMDD(ev.start);
          if (!perDay.has(key)) perDay.set(key, []);
          perDay.get(key).push(ev);
        }

        for (const [key, events] of perDay.entries()) {
          events.sort((a,b) => a.start.getTime() - b.start.getTime());
          const nextEv = events[0];
          const ms = nextEv.start.getTime() - now.getTime();
          const cd = humanCountdown(ms);

          const el = dayChipElsByKey.get(key);
          if (!el) continue;

          el.innerHTML = `${nextEv.icon} <span class="muted">Game</span> in ${cd}`;
          el.style.display = "";
        }
      }

      // FullCalendar
      const calendar = new FullCalendar.Calendar(
        document.getElementById("calendar"),
        {
          initialView: "rolling4Weeks",
          views: { rolling4Weeks: { type: "dayGrid", duration: { weeks: 4 } } },

          firstDay: 0,
          height: "100%",
          expandRows: true,
          showNonCurrentDates: false,
          fixedWeekCount: false,

          dayMaxEvents: true,
          dayMaxEventRows: 4,
          eventMinHeight: 18,

          visibleRange: function(currentDate) {
            const start = startOfCurrentWeekSunday(currentDate);
            const end = new Date(start);
            end.setDate(end.getDate() + 28);
            return { start, end };
          },

          headerToolbar: { left: "", center: "title", right: "" },

          eventSources: [
            { url: ICS_URL, format: "ics" }
          ],

          dayCellDidMount: function(info) {
            const cellDate = startOfDay(info.date);
            const today = startOfDay(new Date());

            const label = holidayLabelForDate(cellDate);
            if (label) {
              info.el.classList.add("is-holiday");
              info.el.setAttribute("data-holiday-label", label);
            }

            const dateKey = toYYYYMMDD(cellDate);
            ensureDayChip(info.el, dateKey);

            if (ENABLE_TODAY_FOCUS && sameDay(cellDate, today)) {
              info.el.classList.add("today-focus");
            }
          },

          eventClassNames: function(arg) {
            const classes = [];
            const title = (arg.event.title || "").trim();
            const meta = classifyEvent(title);
            classes.push("event-" + meta.category);

            const start = arg.event.start;
            if (start && isBigHolidayDate(start)) classes.push("holiday-sparkle");
            return classes;
          },

          eventDidMount: function(arg) {
            if (!ENABLE_TODAY_FOCUS) return;

            const ev = arg.event;
            if (!ev || ev.allDay) return;

            const now = new Date();
            const end = ev.end || new Date(ev.start.getTime() + 60 * 60 * 1000);
            if (end.getTime() < now.getTime() && sameDay(ev.start, now)) {
              arg.el.classList.add("evt-past-today");
            }
          },

          eventContent: function(arg) {
            const title = (arg.event.title || "").trim();
            const isAllDay = arg.event.allDay;
            const timeText = arg.timeText || "";

            const meta = classifyEvent(title);
            const parts = [];
            if (meta.icon) parts.push(`<span class="evt-icon">${meta.icon}</span>`);
            if (!isAllDay && timeText) parts.push(`<span class="evt-time">${escapeHtml(timeText)}</span>`);
            parts.push(`<span class="evt-title">${escapeHtml(title)}</span>`);
            return { html: `<span class="evt">${parts.join("")}</span>` };
          },

          eventsSet: function(events) {
            cachedSportsEvents = normalizeSportsEvents(events);

            const view = calendar.view;
            if (view) updateGameDayChips(view.currentStart, view.currentEnd);
        buildSidebarFromCalendar();
            buildSidebarFromCalendar();
          },

          datesSet: function(info) {
            updateChristmasChip();
            updateGameDayChips(info.start, info.end);
            buildSidebarFromCalendar();
          }
        }
      );

      calendar.render();
      buildSidebarFromCalendar();
      updateChristmasChip();

      // Fetch meals
      fetchMealsForCurrentWeek().catch(err => {
        setMealsStatus(false, err && err.message ? err.message : "Unknown");
        setMealsFooterVisible(true);
      });

      // Auto refresh (events + meals)
      setInterval(() => {
        setLastRefreshed("refreshing‚Ä¶");
        calendar.refetchEvents();
        buildSidebarFromCalendar();

        fetchMealsForCurrentWeek()
          .catch(err => {
            setMealsStatus(false, err && err.message ? err.message : "Unknown");
            setMealsFooterVisible(true);
          })
          .finally(() => setLastRefreshed(`auto ${AUTO_REFRESH_MINUTES}m`));

      }, AUTO_REFRESH_MINUTES * 60 * 1000);

      // Countdown refresh
      setInterval(() => {
        if (!ENABLE_COUNTDOWN_CHIPS && !ENABLE_CHRISTMAS_COUNTDOWN) return;
        updateChristmasChip();
        const view = calendar.view;
        if (view) updateGameDayChips(view.currentStart, view.currentEnd);
        buildSidebarFromCalendar();
            buildSidebarFromCalendar();
      }, COUNTDOWN_REFRESH_SECONDS * 1000);

      /* =========================================================
         WEATHER (Open-Meteo) ‚Äî Fahrenheit (no API key)
         - Tweak refresh: WEATHER_REFRESH_MINUTES
         ========================================================= */
      const HOME_LAT = 38.654398639984805;
      const HOME_LON = -90.45877499401288;
      const WEATHER_REFRESH_MINUTES = 10;

      function weatherCodeToText(code){
        const m = {
          0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",
          45:"Fog",48:"Rime fog",
          51:"Light drizzle",53:"Drizzle",55:"Dense drizzle",
          56:"Freezing drizzle",57:"Freezing drizzle",
          61:"Light rain",63:"Rain",65:"Heavy rain",
          66:"Freezing rain",67:"Freezing rain",
          71:"Light snow",73:"Snow",75:"Heavy snow",77:"Snow grains",
          80:"Rain showers",81:"Rain showers",82:"Violent showers",
          85:"Snow showers",86:"Snow showers",
          95:"Thunderstorm",96:"Thunderstorm hail",99:"Thunderstorm hail"
        };
        return m[code] ?? ("Weather " + code);
      }

      function fmtTime(t){
        try{
          const d = new Date(t);
          return d.toLocaleTimeString([], {hour:"numeric", minute:"2-digit"});
        }catch(e){ return "‚Äî"; }
      }

      async function loadWeather(){
        const url =
          `https://api.open-meteo.com/v1/forecast` +
          `?latitude=${HOME_LAT}&longitude=${HOME_LON}` +
          `&current=temperature_2m,apparent_temperature,weathercode,wind_speed_10m` +
          `&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,weathercode,sunrise,sunset` +
          `&temperature_unit=fahrenheit&windspeed_unit=mph&precipitation_unit=inch` +
          `&timezone=auto&forecast_days=5`;

        const res = await fetch(url, { cache: "no-store" });
        if(!res.ok) throw new Error("Weather fetch failed: " + res.status);
        const data = await res.json();

        const cur = data.current || {};
        const daily = data.daily || {};

        // Current
        const temp = Math.round(cur.temperature_2m ?? NaN);
        const feels = Math.round(cur.apparent_temperature ?? NaN);
        const wind = Math.round(cur.wind_speed_10m ?? NaN);
        const cond = weatherCodeToText(cur.weathercode);

        document.getElementById("weather-temp").textContent = isFinite(temp) ? `${temp}¬∞F` : `--¬∞F`;
        document.getElementById("weather-cond").textContent = cond;
        document.getElementById("weather-feels").textContent = isFinite(feels) ? `Feels like ${feels}¬∞F` : `Feels like ‚Äî`;
        document.getElementById("weather-wind").textContent = isFinite(wind) ? `Wind: ${wind} mph` : `Wind: ‚Äî`;

        // Today stats from daily[0]
        const hi = daily.temperature_2m_max?.[0];
        const lo = daily.temperature_2m_min?.[0];
        const pop = daily.precipitation_probability_max?.[0];
        const sunrise = daily.sunrise?.[0];
        const sunset  = daily.sunset?.[0];

        document.getElementById("weather-hilo").textContent =
          (hi!=null && lo!=null) ? `Hi/Lo: ${Math.round(hi)}¬∞ / ${Math.round(lo)}¬∞` : `Hi/Lo: ‚Äî`;
        document.getElementById("weather-precip").textContent =
          (pop!=null) ? `Precip: ${Math.round(pop)}%` : `Precip: ‚Äî`;
        document.getElementById("weather-sun").textContent =
          (sunrise && sunset) ? `Sun: ${fmtTime(sunrise)}‚Äì${fmtTime(sunset)}` : `Sun: ‚Äî`;

        document.getElementById("weather-updated").textContent =
          `Updated ${new Date().toLocaleTimeString([], {hour:"numeric", minute:"2-digit"})}`;

        // Forecast cards
        const fc = document.getElementById("weather-forecast");
        fc.innerHTML = "";

        const times = daily.time || [];
        for(let i=0;i<Math.min(5, times.length); i++){
          const dt = new Date(times[i] + "T00:00:00");
          const day = dt.toLocaleDateString([], { weekday: "short" });
          const fhi = daily.temperature_2m_max?.[i];
          const flo = daily.temperature_2m_min?.[i];
          const fpop = daily.precipitation_probability_max?.[i];
          const fcode = daily.weathercode?.[i];
          const ftext = weatherCodeToText(fcode);

          const card = document.createElement("div");
          card.className = "day-card";
          card.innerHTML = `
            <div class="d">${day}</div>
            <div class="hi">${(fhi!=null)?Math.round(fhi):"‚Äî"}¬∞</div>
            <div class="lo">Low ${(flo!=null)?Math.round(flo):"‚Äî"}¬∞</div>
            <div class="p">${(fpop!=null)?Math.round(fpop):"‚Äî"}% ‚Ä¢ ${escapeHtml(ftext)}</div>
          `;
          fc.appendChild(card);
        }
      }

      // Kick off weather after DOM is ready; keep it independent of calendar load.
      try{
        loadWeather();
        setInterval(loadWeather, WEATHER_REFRESH_MINUTES * 60 * 1000);
      }catch(e){
        console.warn("Weather init error:", e);
      }

      function escapeHtml(str) {
        return String(str)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }
    });
  </script>
  </div>

  <div id="bottom-area">
    <section class="bottom-panel" id="weather-panel" aria-label="Weather">
      <div id="weather-top">
        <div id="weather-temp">--¬∞F</div>
        <div id="weather-meta">
          <div class="cond" id="weather-cond">Loading‚Ä¶</div>
          <div class="sub" id="weather-feels">Feels like ‚Äî</div>
          <div class="sub" id="weather-updated">‚Äî</div>
        </div>
      </div>

      <div id="weather-stats">
        <div class="stat-pill" id="weather-wind">Wind: ‚Äî</div>
        <div class="stat-pill" id="weather-precip">Precip: ‚Äî</div>
        <div class="stat-pill" id="weather-hilo">Hi/Lo: ‚Äî</div>
        <div class="stat-pill" id="weather-sun">Sun: ‚Äî</div>
      </div>

      <div id="weather-forecast"></div>
    </section>

        <div id="bottom-spacer"></div>

        <section class="bottom-panel" id="traffic-panel" aria-label="Traffic map">
      <div id="traffic-label">Traffic (Waze)</div>
      <iframe
        src="https://embed.waze.com/iframe?zoom=13&lat=38.638412&lon=-90.457971&ct=livemap"
        allowfullscreen
        loading="lazy"
        referrerpolicy="no-referrer-when-downgrade">
      </iframe>
    </section>
  </div>
</div>

</body>
</html>
